package realdeepmind;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProjectBehnamAskariAzmoonManApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProjectBehnamAskariAzmoonManApplication.class, args);
    }

}
package realdeepmind.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import realdeepmind.dto.LoginDto;
import realdeepmind.dto.user.UserRegisterDto;
import realdeepmind.entity.User;
import realdeepmind.mapper.UserMapper;
import realdeepmind.security.JwtUtils;
import realdeepmind.service.user.UserService;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthRestController {

    private final AuthenticationManager authenticationManager;
    private final UserService userService;
    private final UserMapper userMapper;
    private final JwtUtils jwtUtils;
    private final UserDetailsService userDetailsService;

    // ثبت‌نام کاربر جدید
    @PostMapping("/register")
    public ResponseEntity<String> register(@RequestBody UserRegisterDto registerDto) {
        User user = userMapper.toEntity(registerDto);
        userService.signUp(user);
        return ResponseEntity.ok("User registered successfully! Please wait for admin approval.");
    }

    // ورود و دریافت توکن
    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginDto loginDto) {
        // ۱. احراز هویت (چک کردن یوزرنیم و پسورد)
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginDto.getUsername(), loginDto.getPassword())
        );

        // ۲. بارگذاری اطلاعات کاربر برای ساخت توکن
        final UserDetails userDetails = userDetailsService.loadUserByUsername(loginDto.getUsername());

        // ۳. تولید توکن
        String token = jwtUtils.generateToken(userDetails);

        return ResponseEntity.ok(token);
    }
}
package realdeepmind.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import realdeepmind.dto.course.CourseDto;
import realdeepmind.dto.course.CourseResponseDto;
import realdeepmind.dto.course_enrollment.EnrollmentRequestDto;
import realdeepmind.dto.course_enrollment.EnrollmentResponseDto;
import realdeepmind.entity.Course;
import realdeepmind.entity.CourseEnrollment;
import realdeepmind.mapper.CourseEnrollmentMapper;
import realdeepmind.mapper.CourseMapper;
import realdeepmind.service.course.CourseService;
import realdeepmind.service.course_enrollment.CourseEnrollmentService;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/courses")
@RequiredArgsConstructor
public class CourseController {

    private final CourseService courseService;
    private final CourseEnrollmentService enrollmentService;
    private final CourseMapper courseMapper;
    private final CourseEnrollmentMapper enrollmentMapper;

    // ۱. ایجاد دوره جدید (فقط ادمین)
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CourseResponseDto> createCourse(@RequestBody CourseDto courseDto) {
        Course course = courseMapper.toEntity(courseDto);
        Course savedCourse = courseService.createCourse(course);
        return ResponseEntity.ok(courseMapper.toDto(savedCourse));
    }

    // ۲. ثبت‌نام کاربر (استاد یا دانشجو) در دوره (فقط ادمین)
    @PostMapping("/enroll")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<EnrollmentResponseDto> enrollUser(@RequestBody EnrollmentRequestDto requestDto) {
        CourseEnrollment enrollment = enrollmentService.enroll(
                requestDto.getUserId(),
                requestDto.getCourseId(),
                requestDto.getRole()
        );
        return ResponseEntity.ok(enrollmentMapper.toDto(enrollment));
    }

    // ۳. مشاهده لیست همه دوره‌ها (برای همه کاربران لاگین شده)
    @GetMapping
    public ResponseEntity<List<CourseResponseDto>> getAllCourses() {
        List<Course> courses = courseService.getAllCourses();
        List<CourseResponseDto> dtos = courses.stream()
                .map(courseMapper::toDto)
                .collect(Collectors.toList());
        return ResponseEntity.ok(dtos);
    }

    // ۴. مشاهده لیست افراد حاضر در یک کلاس خاص (فقط ادمین و استاد)
    @GetMapping("/{courseId}/users")
    @PreAuthorize("hasAnyRole('ADMIN', 'TEACHER')")
    public ResponseEntity<List<EnrollmentResponseDto>> getCourseUsers(@PathVariable Long courseId) {
        List<CourseEnrollment> enrollments = enrollmentService.findByCourseId(courseId);
        List<EnrollmentResponseDto> dtos = enrollments.stream()
                .map(enrollmentMapper::toDto)
                .collect(Collectors.toList());
        return ResponseEntity.ok(dtos);
    }
}
package realdeepmind.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import realdeepmind.dto.user.UserRegisterDto;
import realdeepmind.dto.user.UserResponseDto;
import realdeepmind.entity.User;
import realdeepmind.entity.enums.Role;
import realdeepmind.entity.enums.UserStatus;
import realdeepmind.mapper.UserMapper;
import realdeepmind.repository.UserRepository;
import realdeepmind.service.user.UserService;

import java.security.Principal;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;
    private final UserMapper userMapper;

    // ۱. لیست کاربران در انتظار تایید (فقط مدیر)
    @GetMapping("/waiting")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<UserResponseDto>> getWaitingUsers() {
        List<User> users = userService.findByUserStatus(UserStatus.WAITING);
        return ResponseEntity.ok(users.stream().map(userMapper::toDto).collect(Collectors.toList()));
    }

    // ۲. تایید یا رد کاربر (تغییر وضعیت) - فقط مدیر
    @PutMapping("/{id}/status")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> changeStatus(@PathVariable Long id, @RequestParam UserStatus status) {
        userService.changeUserStatus(id, status);
        return ResponseEntity.ok("User status updated to " + status);
    }

    // ۳. ویرایش اطلاعات کاربر (نام و نام خانوادگی) - فقط مدیر
    // طبق مستندات مدیر می‌تواند اطلاعات کاربران را ویرایش کند
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<UserResponseDto> updateUser(@PathVariable Long id, @RequestBody UserRegisterDto userDto) {
        // تبدیل DTO به Entity
        User userUpdateInfo = userMapper.toEntity(userDto);
        userUpdateInfo.setId(id); // تنظیم ID برای اینکه سرویس بفهمد کدام کاربر است

        User updatedUser = userService.updateUser(userUpdateInfo);
        return ResponseEntity.ok(userMapper.toDto(updatedUser));
    }

    // ۴. تغییر نقش کاربر (مثلاً دانشجو به استاد) - فقط مدیر
    @PutMapping("/{id}/role")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> changeRole(@PathVariable Long id, @RequestParam Role role) {
        userService.changeUserRole(id, role);
        return ResponseEntity.ok("User role updated to " + role);
    }

    // ۵. جستجو و فیلتر کاربران
    @GetMapping("/search")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<UserResponseDto>> searchUsers(
            @RequestParam(required = false) String firstName,
            @RequestParam(required = false) String lastName,
            @RequestParam(required = false) Role role,
            @RequestParam(required = false) UserStatus status
    ) {
        List<User> users = userService.searchUsers(firstName, lastName, role, status);
        return ResponseEntity.ok(users.stream().map(userMapper::toDto).collect(Collectors.toList()));
    }
    // ۶. ویرایش پروفایل شخصی (برای هر کاربر لاگین شده)
    @PutMapping("/profile")
    public ResponseEntity<UserResponseDto> updateMyProfile(
            @RequestBody UserRegisterDto userDto,
            Principal principal // این آبجکت اطلاعات کاربری که الان لاگین هست را دارد
    ) {
        // ۱. پیدا کردن کاربری که درخواست داده (از طریق نام کاربری داخل توکن)
        String currentUsername = principal.getName();
        User currentUser = userService.findByUsername(currentUsername)
                .orElseThrow(() -> new RuntimeException("Current user not found"));

        // ۲. فقط فیلدهای مجاز را آپدیت می‌کنیم
        // نکته: اجازه نمی‌دهیم کاربر نقش یا وضعیت خود را تغییر دهد!
        currentUser.setFirstName(userDto.getFirstName());
        currentUser.setLastName(userDto.getLastName());

        // اگر خواستی کاربر بتواند پسوردش را هم عوض کند، منطقش جداست (در ادامه می‌گویم)

        // ۳. ذخیره تغییرات
        User updatedUser = userService.updateUser(currentUser);

        return ResponseEntity.ok(userMapper.toDto(updatedUser));
    }
}
package realdeepmind.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class LoginDto {
    @NotBlank
    private String username;

    @NotBlank
    private String password;
}
package realdeepmind.dto.course;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;
import lombok.Data;

import java.time.LocalDate;

@Data
@Builder
public class CourseDto {
    @NotBlank
    private String title;

    @NotBlank
    private String courseCode;

    @NotNull
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate startDate;

    @NotNull
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate endDate;
}
package realdeepmind.dto.course;

import lombok.Builder;
import lombok.Data;

import java.time.LocalDate;

@Data
@Builder
public class CourseResponseDto {
    private Long id;
    private String title;
    private String courseCode;
    private LocalDate startDate;
    private LocalDate endDate;
    private Integer duration;
}
package realdeepmind.dto.course_enrollment;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import realdeepmind.entity.enums.RoleInCourse;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EnrollmentRequestDto {
    @NotNull(message = "User ID is required")
    private Long userId;

    @NotNull(message = "Course ID is required")
    private Long courseId;

    @NotNull(message = "Role in course is required")
    private RoleInCourse role;
}
package realdeepmind.dto.course_enrollment;

import lombok.Builder;
import lombok.Data;
import realdeepmind.entity.enums.RoleInCourse;

import java.time.LocalDateTime;

@Data
@Builder
public class EnrollmentResponseDto {
    private Long id;
    private Long userId;
    private String userFullName;
    private String username;

    private Long courseId;
    private String courseTitle;

    private RoleInCourse role;
    private Double grade;
    private LocalDateTime enrollmentDate;
}
package realdeepmind.dto.user;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Builder;
import lombok.Data;
import realdeepmind.entity.enums.Role;

@Data
@Builder
public class UserRegisterDto {
    @NotBlank(message = "First name is required")
    private String firstName;

    @NotBlank(message = "Last name is required")
    private String lastName;

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Password is required")
    @Size(min = 6, max = 20, message = "Password must be between 6 and 20 characters")
    private String password;

    private Role role;
}
package realdeepmind.dto.user;

import lombok.Builder;
import lombok.Data;
import realdeepmind.entity.enums.Role;
import realdeepmind.entity.enums.UserStatus;

@Data
@Builder
public class UserResponseDto {
    private Long id;
    private String firstName;
    private String lastName;
    private String username;
    private Role role;
    private UserStatus status;
}
package realdeepmind.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "courses")
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;
    @NotBlank(message = "title cannot be empty")
    @Column(nullable = false)
    private String title;
    @NotBlank(message = "courseCode cannot be empty")
    @Column(nullable = false, unique = true)
    private String courseCode;
    @NotNull(message = "start date cannot be null")
    private LocalDate startDate;
    @NotNull(message = "end date cannot be null")
    private LocalDate endDate;
    private Integer duration;
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    @ToString.Exclude
    @Builder.Default
    private List<CourseEnrollment> enrollments = new ArrayList<>();

}
package realdeepmind.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import realdeepmind.entity.enums.RoleInCourse;

import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "course_enrollments")
public class CourseEnrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne(optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    @ManyToOne(optional = false)
    @JoinColumn(name = "course_id", nullable = false)
    private Course course;
    private Double grade;
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private RoleInCourse roleInCourse;
    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime enrollmentDate;


}
package realdeepmind.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;
import realdeepmind.entity.enums.Role;
import realdeepmind.entity.enums.UserStatus;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @NotBlank(message = "firstname cannot be empty")
    @Column(nullable = false)
    private String firstName;
    @NotBlank(message = "lastname cannot be empty")
    @Column(nullable = false)
    private String lastName;
    @NotBlank(message = "username cannot be empty")
    @Column(nullable = false, unique = true)
    private String username;
    @NotBlank(message = "password cannot be empty")
    @Size(min = 6, max = 20)
    private String password;
    @NotNull(message = "role cannot be empty")
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private Role role;
    @NotNull(message = "status cannot be empty")
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    private UserStatus userStatus;
    private String rejectionReason;
    @OneToMany(mappedBy = "user")
    @JsonIgnore
    @ToString.Exclude
    @Builder.Default
    private List<CourseEnrollment> enrollments = new ArrayList<>();
}
package realdeepmind.entity.enums;

public enum Role {
    ADMIN,
    TEACHER,
    STUDENT
}
package realdeepmind.entity.enums;

public enum RoleInCourse {
    TEACHER,
    STUDENT
}
package realdeepmind.entity.enums;

public enum UserStatus {
    WAITING,
    APPROVED,
    REJECTED
}
package realdeepmind.mapper;

import org.springframework.stereotype.Component;
import realdeepmind.dto.course_enrollment.EnrollmentResponseDto;
import realdeepmind.entity.CourseEnrollment;

@Component
public class CourseEnrollmentMapper {

    public EnrollmentResponseDto toDto(CourseEnrollment enrollment) {
        if (enrollment == null) {
            return null;
        }

        return EnrollmentResponseDto.builder()
                .id(enrollment.getId())
                .userId(enrollment.getUser().getId())
                .userFullName(enrollment.getUser().getFirstName() + " " + enrollment.getUser().getLastName())
                .username(enrollment.getUser().getUsername())
                .courseId(enrollment.getCourse().getId())
                .courseTitle(enrollment.getCourse().getTitle())
                .role(enrollment.getRoleInCourse())
                .grade(enrollment.getGrade())
                .enrollmentDate(enrollment.getEnrollmentDate())
                .build();
    }
}
package realdeepmind.mapper;

import org.springframework.stereotype.Component;
import realdeepmind.dto.course.CourseDto;
import realdeepmind.dto.course.CourseResponseDto;
import realdeepmind.entity.Course;

import java.time.temporal.ChronoUnit;

@Component
public class CourseMapper {

    public Course toEntity(CourseDto dto) {
        if (dto == null) {
            return null;
        }

        Course.CourseBuilder courseBuilder = Course.builder()
                .title(dto.getTitle())
                .courseCode(dto.getCourseCode())
                .startDate(dto.getStartDate())
                .endDate(dto.getEndDate());

        if (dto.getStartDate() != null && dto.getEndDate() != null) {
            long days = ChronoUnit.DAYS.between(dto.getStartDate(), dto.getEndDate());
            courseBuilder.duration((int) days);
        }

        return courseBuilder.build();
    }

    public CourseResponseDto toDto(Course course) {
        if (course == null) {
            return null;
        }

        return CourseResponseDto.builder()
                .id(course.getId())
                .title(course.getTitle())
                .courseCode(course.getCourseCode())
                .startDate(course.getStartDate())
                .endDate(course.getEndDate())
                .duration(course.getDuration())
                .build();
    }
}
package realdeepmind.mapper;

import org.springframework.stereotype.Component;
import realdeepmind.dto.user.UserRegisterDto;
import realdeepmind.dto.user.UserResponseDto;
import realdeepmind.entity.User;

@Component
public class UserMapper {

    public User toEntity(UserRegisterDto dto) {
        if (dto == null) {
            return null;
        }

        return User.builder()
                .firstName(dto.getFirstName())
                .lastName(dto.getLastName())
                .username(dto.getUsername())
                .password(dto.getPassword())
                .role(dto.getRole())
                .build();
    }

    public UserResponseDto toDto(User user) {
        if (user == null) {
            return null;
        }

        return UserResponseDto.builder()
                .id(user.getId())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .username(user.getUsername())
                .role(user.getRole())
                .status(user.getUserStatus())
                .build();
    }
}
package realdeepmind.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import realdeepmind.entity.CourseEnrollment;
import realdeepmind.entity.enums.RoleInCourse;

import java.util.List;
import java.util.Optional;

@Repository
public interface CourseEnrollmentRepository extends JpaRepository<CourseEnrollment, Long> {
    boolean existsByUserIdAndCourseId(Long userId, Long courseId);

    Optional<CourseEnrollment> findByUserIdAndCourseId(Long userId, Long courseId);

    List<CourseEnrollment> findByUserId(Long userId);

    List<CourseEnrollment> findByCourseId(Long courseId);

    @Query("SELECT ce FROM CourseEnrollment ce WHERE " +
            "(:courseId IS NULL OR ce.course.id = :courseId) AND " +
            "(:userId IS NULL OR ce.user.id = :userId) AND " +
            "(:role IS NULL OR ce.roleInCourse = :role)")
    List<CourseEnrollment> searchEnrollments(@Param("courseId") Long courseId,
                                             @Param("userId") Long userId,
                                             @Param("role") RoleInCourse role);
}
package realdeepmind.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import realdeepmind.entity.Course;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface CourseRepository extends JpaRepository<Course, Long> {
    Optional<Course> findByCourseCode(String courseCode);

    boolean existsByCourseCode(String courseCode);

    @Query("SELECT c FROM Course c JOIN c.enrollments e WHERE e.user.id = :teacherId AND e.roleInCourse = 'TEACHER'")
    List<Course> findCoursesByTeacherId(@Param("teacherId") Long teacherId);

    @Query(
            value = "SELECT c.* FROM courses c " +
                    "INNER JOIN course_enrollments ce ON c.id = ce.course_id " +
                    "WHERE ce.user_id = :userId AND ce.role_in_course = 'STUDENT'",
            nativeQuery = true

    )
    List<Course> findCoursesByStudentId(@Param("userId") Long userId);

    @Query("SELECT c FROM Course c LEFT JOIN c.enrollments e WHERE e.id IS NULL")
    List<Course> findCoursesWithNoEnrollments();

    List<Course> findByTitleContainingIgnoreCase(String title);

    List<Course> findByStartDateAfter(LocalDate startDate);

    List<Course> findByEndDateBefore(LocalDate endDate);

    List<Course> findByStartDateLessThanEqualAndEndDateGreaterThanEqual(LocalDate startDate, LocalDate endDate);

    List<Course> findByDurationGreaterThan(Integer duration);

    List<Course> findByDurationLessThan(Integer duration);


}
package realdeepmind.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import realdeepmind.entity.User;
import realdeepmind.entity.enums.Role;
import realdeepmind.entity.enums.UserStatus;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> , JpaSpecificationExecutor<User> {
    Optional<User> findByUsername(String username);

    boolean existsByUsername(String username);

    @Query(
            "select u from User u join u.enrollments e " +
                    "where e.course.id = :courseId and e.roleInCourse = 'STUDENT'"
    )
    List<User> findStudentsByCourseId(@Param("courseId") Long courseId);

    @Query(
            "select u from User u join u.enrollments e " +
                    "where e.course.id = :courseId and e.roleInCourse = 'TEACHER'"
    )
    Optional<User> findTeacherByCourseId(@Param("courseId") Long courseId);


    List<User> findByUserStatus(UserStatus userStatus);

    List<User> findByRole(Role role);

    List<User> findByRoleAndUserStatus(Role role, UserStatus userStatus);

    List<User> findByFirstNameContainsIgnoreCaseAndLastNameContainingIgnoreCase(String firstName, String lastName);

    @Query("SELECT u FROM User u WHERE " +
            "(:firstName IS NULL OR LOWER(u.firstName) LIKE LOWER(CONCAT('%', :firstName, '%'))) AND " +
            "(:lastName IS NULL OR LOWER(u.lastName) LIKE LOWER(CONCAT('%', :lastName, '%'))) AND " +
            "(:role IS NULL OR u.role = :role) AND " +
            "(:status IS NULL OR u.userStatus = :status)")
    List<User> searchUsers(@Param("firstName") String firstName,
                           @Param("lastName") String lastName,
                           @Param("role") Role role,
                           @Param("status") UserStatus status);


}
package realdeepmind.security;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import realdeepmind.entity.User;
import realdeepmind.repository.UserRepository;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

public class CustomUserDetails implements UserDetails {
    private final User user;

    public CustomUserDetails(User user) {
        this.user = user;
    }


    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_"+user.getRole().name()));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public User getUser() {
        return user;
    }
}
package realdeepmind.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtUtils jwtUtils;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String jwtToken;
        final String username;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        jwtToken = authHeader.substring(7);

        username = jwtUtils.extractUsername(jwtToken);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);

            if (jwtUtils.isTokenValid(jwtToken, userDetails)) {

                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                );

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}
package realdeepmind.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtils {


    private static final String SECRET_KEY = "404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970";

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {
        return Jwts
                .builder()
                .setClaims(extraClaims)
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24))
                .signWith(getSignInKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSignInKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
package realdeepmind.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity // فعال‌سازی @PreAuthorize برای چک کردن نقش‌ها در آینده
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final JwtAuthFilter jwtAuthFilter;
    private final UserDetailsService userDetailsService;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)

                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**").permitAll()

                        .anyRequest().authenticated()
                )

                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )

                .authenticationProvider(authenticationProvider())

                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }


    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();

        authProvider.setUserDetailsService(userDetailsService);

        authProvider.setPasswordEncoder(passwordEncoder());

        return authProvider;
    }


    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
        //return NoOpPasswordEncoder.getInstance();
    }
}
package realdeepmind.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import realdeepmind.entity.User;
import realdeepmind.repository.UserRepository;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        return new CustomUserDetails(user);
    }
}
package realdeepmind.service.course;

import realdeepmind.entity.Course;

import java.time.LocalDate;
import java.util.List;

public interface CourseService {

    Course createCourse(Course course);

    Course updateCourse(Course course);

    void deleteCourse(Long id);

    Course getCourseById(Long id);

    Course getCourseByCode(String courseCode);

    List<Course> getAllCourses();

    List<Course> getCoursesByTeacher(Long teacherId);

    List<Course> getCoursesByStudent(Long studentId);

    List<Course> getCoursesWithNoEnrollments();

    List<Course> searchByTitle(String title);

    List<Course> filterByStartDateAfter(LocalDate date);

    List<Course> filterByEndDateBefore(LocalDate date);

    List<Course> filterByDurationGreaterThan(Integer duration);
}
package realdeepmind.service.course;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import realdeepmind.entity.Course;
import realdeepmind.repository.CourseRepository;

import java.time.LocalDate;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class CourseServiceImpl implements CourseService {

    private final CourseRepository courseRepository;

    @Override
    public Course createCourse(Course course) {
        if (courseRepository.existsByCourseCode(course.getCourseCode())) {
            throw new RuntimeException("Course code already exists: " + course.getCourseCode());
        }
        return courseRepository.save(course);
    }

    @Override
    public Course updateCourse(Course course) {
        Course existingCourse = courseRepository.findById(course.getId())
                .orElseThrow(() -> new RuntimeException("Course not found."));

        existingCourse.setTitle(course.getTitle());
        existingCourse.setStartDate(course.getStartDate());
        existingCourse.setEndDate(course.getEndDate());
        existingCourse.setDuration(course.getDuration());

        return courseRepository.save(existingCourse);
    }

    @Override
    public void deleteCourse(Long id) {
        if (!courseRepository.existsById(id)) {
            throw new RuntimeException("Course not found.");
        }
        courseRepository.deleteById(id);
    }

    @Override
    public Course getCourseById(Long id) {
        return courseRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Course not found."));
    }

    @Override
    public Course getCourseByCode(String courseCode) {
        return courseRepository.findByCourseCode(courseCode)
                .orElseThrow(() -> new RuntimeException("Course not found with code: " + courseCode));
    }

    @Override
    public List<Course> getAllCourses() {
        return courseRepository.findAll();
    }

    @Override
    public List<Course> getCoursesByTeacher(Long teacherId) {
        return courseRepository.findCoursesByTeacherId(teacherId);
    }

    @Override
    public List<Course> getCoursesByStudent(Long studentId) {
        return courseRepository.findCoursesByStudentId(studentId);
    }

    @Override
    public List<Course> getCoursesWithNoEnrollments() {
        return courseRepository.findCoursesWithNoEnrollments();
    }

    @Override
    public List<Course> searchByTitle(String title) {
        return courseRepository.findByTitleContainingIgnoreCase(title);
    }

    @Override
    public List<Course> filterByStartDateAfter(LocalDate date) {
        return courseRepository.findByStartDateAfter(date);
    }

    @Override
    public List<Course> filterByEndDateBefore(LocalDate date) {
        return courseRepository.findByEndDateBefore(date);
    }

    @Override
    public List<Course> filterByDurationGreaterThan(Integer duration) {
        return courseRepository.findByDurationGreaterThan(duration);
    }
}
package realdeepmind.service.course_enrollment;

import realdeepmind.entity.CourseEnrollment;
import realdeepmind.entity.enums.RoleInCourse;

import java.util.List;
import java.util.Optional;

public interface CourseEnrollmentService {


    CourseEnrollment enroll(Long userId, Long courseId, RoleInCourse role);

    CourseEnrollment assignGrade(Long userId, Long courseId, Double grade);

    void unenroll(Long userId, Long courseId);


    void deleteById(Long id);

    Optional<CourseEnrollment> findById(Long id);

    List<CourseEnrollment> findAll();

    boolean isEnrolled(Long userId, Long courseId);

    Optional<CourseEnrollment> findByUserIdAndCourseId(Long userId, Long courseId);

    List<CourseEnrollment> findByUserId(Long userId);

    List<CourseEnrollment> findByCourseId(Long courseId);

    List<CourseEnrollment> searchEnrollments(Long courseId, Long userId, RoleInCourse role);
}
package realdeepmind.service.course_enrollment;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import realdeepmind.entity.Course;
import realdeepmind.entity.CourseEnrollment;
import realdeepmind.entity.User;
import realdeepmind.entity.enums.RoleInCourse;
import realdeepmind.repository.CourseEnrollmentRepository;
import realdeepmind.repository.CourseRepository;
import realdeepmind.repository.UserRepository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class CourseEnrollmentServiceImpl implements CourseEnrollmentService {

    private final CourseEnrollmentRepository enrollmentRepository;
    private final UserRepository userRepository;
    private final CourseRepository courseRepository;

    @Override
    public CourseEnrollment enroll(Long userId, Long courseId, RoleInCourse role) {
        if (enrollmentRepository.existsByUserIdAndCourseId(userId, courseId)) {
            throw new RuntimeException("User is already enrolled in this course.");
        }

        if (role == RoleInCourse.TEACHER) {
            if (userRepository.findTeacherByCourseId(courseId).isPresent()) {
                throw new RuntimeException("Error: This course already has a teacher.");
            }
        }

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found."));

        Course course = courseRepository.findById(courseId)
                .orElseThrow(() -> new RuntimeException("Course not found."));

        CourseEnrollment enrollment = CourseEnrollment.builder()
                .user(user)
                .course(course)
                .roleInCourse(role)
                .enrollmentDate(LocalDateTime.now())
                .build();

        return enrollmentRepository.save(enrollment);
    }

    @Override
    public CourseEnrollment assignGrade(Long userId, Long courseId, Double grade) {
        CourseEnrollment enrollment = enrollmentRepository.findByUserIdAndCourseId(userId, courseId)
                .orElseThrow(() -> new RuntimeException("Enrollment not found for this user and course."));

        if (enrollment.getRoleInCourse() != RoleInCourse.STUDENT) {
            throw new RuntimeException("Grades can only be assigned to students.");
        }

        enrollment.setGrade(grade);
        return enrollmentRepository.save(enrollment);
    }

    @Override
    public void unenroll(Long userId, Long courseId) {
        CourseEnrollment enrollment = enrollmentRepository.findByUserIdAndCourseId(userId, courseId)
                .orElseThrow(() -> new RuntimeException("Enrollment not found."));

        enrollmentRepository.delete(enrollment);
    }

    @Override
    public void deleteById(Long id) {
        enrollmentRepository.deleteById(id);
    }

    @Override
    public Optional<CourseEnrollment> findById(Long id) {
        return enrollmentRepository.findById(id);
    }

    @Override
    public List<CourseEnrollment> findAll() {
        return enrollmentRepository.findAll();
    }

    @Override
    public boolean isEnrolled(Long userId, Long courseId) {
        return enrollmentRepository.existsByUserIdAndCourseId(userId, courseId);
    }

    @Override
    public Optional<CourseEnrollment> findByUserIdAndCourseId(Long userId, Long courseId) {
        return enrollmentRepository.findByUserIdAndCourseId(userId, courseId);
    }

    @Override
    public List<CourseEnrollment> findByUserId(Long userId) {
        return enrollmentRepository.findByUserId(userId);
    }

    @Override
    public List<CourseEnrollment> findByCourseId(Long courseId) {
        return enrollmentRepository.findByCourseId(courseId);
    }

    @Override
    public List<CourseEnrollment> searchEnrollments(Long courseId, Long userId, RoleInCourse role) {
        return enrollmentRepository.searchEnrollments(courseId, userId, role);
    }
}
package realdeepmind.service.user;

import realdeepmind.entity.User;
import realdeepmind.entity.enums.Role;
import realdeepmind.entity.enums.UserStatus;

import java.util.List;
import java.util.Optional;


public interface UserService {
    User signUp(User user);


    User updateUser(User user);

    void changePassword(Long userId, String oldPassword, String newPassword);


    void deleteById(Long id);

    Optional<User> findById(Long id);

    List<User> findAll();


    Optional<User> findByUsername(String username);

    boolean existsByUsername(String username);

    List<User> findStudentsByCourseId(Long courseId);

    Optional<User> findTeacherByCourseId(Long courseId);

    List<User> findByUserStatus(UserStatus userStatus);

    List<User> findByRole(Role role);

    List<User> findByRoleAndUserStatus(Role role, UserStatus userStatus);

    List<User> searchUsers(String firstName, String lastName, Role role, UserStatus status);

    void changeUserStatus(Long userId, UserStatus newStatus);

    public void changeUserRole(Long userId, Role newRole);


}
package realdeepmind.service.user;

import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import realdeepmind.entity.User;
import realdeepmind.entity.enums.Role;
import realdeepmind.entity.enums.UserStatus;
import realdeepmind.repository.UserRepository;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Override
    @Transactional
    public User signUp(User user) {
        if (userRepository.existsByUsername(user.getUsername())) {
            throw new RuntimeException("Username is already taken: " + user.getUsername());
        }
        if (user.getUserStatus() == null) {
            user.setUserStatus(UserStatus.WAITING);
        }
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        return userRepository.save(user);
    }

    @Override
    @Transactional
    public User updateUser(User user) {
        User existingUser = userRepository.findById(user.getId())
                .orElseThrow(() -> new RuntimeException("User not found."));

        existingUser.setFirstName(user.getFirstName());
        existingUser.setLastName(user.getLastName());

        return userRepository.save(existingUser);
    }

    @Override
    @Transactional
    public void changePassword(Long userId, String oldPassword, String newPassword) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found."));

        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new RuntimeException("invalid old password");
        }

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }

    @Override
    @Transactional
    public void deleteById(Long id) {
        userRepository.deleteById(id);
    }

    @Override
    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }

    @Override
    public List<User> findAll() {
        return userRepository.findAll();
    }

    @Override
    public Optional<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    @Override
    public boolean existsByUsername(String username) {
        return userRepository.existsByUsername(username);
    }

    @Override
    public List<User> findStudentsByCourseId(Long courseId) {
        return userRepository.findStudentsByCourseId(courseId);
    }

    @Override
    public Optional<User> findTeacherByCourseId(Long courseId) {
        return userRepository.findTeacherByCourseId(courseId);
    }

    @Override
    public List<User> findByUserStatus(UserStatus userStatus) {
        return userRepository.findByUserStatus(userStatus);
    }

    @Override
    public List<User> findByRole(Role role) {
        return userRepository.findByRole(role);
    }

    @Override
    public List<User> findByRoleAndUserStatus(Role role, UserStatus userStatus) {
        return userRepository.findByRoleAndUserStatus(role, userStatus);
    }

    @Override
    public List<User> searchUsers(String firstName, String lastName, Role role, UserStatus status) {
        return userRepository.searchUsers(firstName, lastName, role, status);
    }

    @Override
    @Transactional
    public void changeUserStatus(Long userId, UserStatus newStatus) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        user.setUserStatus(newStatus);
        userRepository.save(user);
    }

    @Override
    @Transactional
    public void changeUserRole(Long userId, Role newRole) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        user.setRole(newRole);
        userRepository.save(user);
    }
}
